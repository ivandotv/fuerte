{"version":3,"file":"core.js","sources":["../../src/model/identity-error.ts","../../src/model/Model.ts","../../src/utils/utils.ts","../../src/collection/LiteCollection.ts","../../src/collection/Collection.ts","../../src/transport/transport.ts"],"sourcesContent":["export class IdentityError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'Identity Error'\n  }\n}\n","import equal from 'fast-deep-equal'\nimport {\n  action,\n  autorun,\n  computed,\n  IReactionDisposer,\n  makeObservable,\n  observable\n} from 'mobx'\nimport { nanoid } from 'nanoid/non-secure'\nimport { LiteCollection } from '../collection/LiteCollection'\nimport { Transport } from '../transport/transport'\nimport {\n  DeleteConfig,\n  ModelDeleteErrorCallback,\n  ModelDeleteStartCallback,\n  ModelDeleteSuccessCallback,\n  ModelSaveErrorCallback,\n  ModelSaveStartCallback,\n  ModelSaveSuccessCallback,\n  ModelTransportErrors,\n  SaveConfig\n} from '../utils/types'\nimport { IdentityError } from './identity-error'\n\n// @ts-expect-error: using return type on a protected method\ntype Payload<T extends Model> = ReturnType<T['serialize']>\n\nexport abstract class Model<\n  TCollection extends LiteCollection<any, any> = LiteCollection<any, any>\n> {\n  static identityKey = 'cid'\n\n  static setIdentityFromResponse = false\n\n  readonly collection: TCollection | undefined\n\n  readonly cid: string\n\n  protected errors: ModelTransportErrors = {\n    save: null,\n    delete: null\n  }\n\n  protected _isDeleted = false\n\n  protected _isSaving = false\n\n  protected _isDeleting = false\n\n  protected ignoreChange = false\n\n  protected _isDestroyed = false\n\n  protected payloadActionDisposer!: IReactionDisposer\n\n  protected initialized = false\n\n  protected pendingSaveCall:\n    | {\n        token: Record<string, never>\n        state: 'pending' | 'resolved' | 'rejected'\n      }\n    | undefined\n\n  lastSavedData: Payload<this> | undefined = undefined\n\n  get identityKey(): string {\n    return (this.constructor as typeof Model).identityKey\n  }\n\n  constructor() {\n    this.cid = nanoid()\n\n    makeObservable<\n      this,\n      | '_isDeleted'\n      | '_isSaving'\n      | '_isDestroyed'\n      | '_isDeleting'\n      | 'errors'\n      | 'computePayload'\n      | 'lastSavedData'\n    >(this, {\n      init: action,\n      _isDeleted: observable,\n      isDeleted: computed,\n\n      _isSaving: observable,\n      isSaving: computed,\n\n      _isDeleting: observable,\n      isDeleting: computed,\n\n      isDirty: computed,\n      _isDestroyed: observable,\n      isDestroyed: computed,\n\n      isSyncing: computed,\n      lastSavedData: observable,\n\n      isNew: computed,\n\n      computePayload: computed.struct,\n      payload: computed,\n\n      setIdentity: action,\n      identity: computed,\n      hasErrors: computed,\n      errors: observable,\n      saveError: computed,\n      deleteError: computed,\n      _onAdded: action,\n      _onRemoved: action,\n\n      _onSaveStart: action,\n      _onSaveSuccess: action,\n      _onSaveError: action,\n      _onDeleteError: action,\n      _onDeleteStart: action,\n      _onDeleteSuccess: action,\n      destroy: action\n    })\n  }\n\n  // @internal\n  init(): void {\n    if (this.initialized) return\n    this.payloadActionDisposer = this.startPayloadCompute()\n    this.lastSavedData = this.payload\n    this.initialized = true\n  }\n\n  // https://alexhisen.gitbook.io/mobx-recipes/use-computedstruct-for-computed-objects\n  get payload(): Payload<this> {\n    return this.computePayload\n  }\n\n  //computed struct\n  protected get computePayload(): Payload<this> {\n    return this.serialize()\n  }\n\n  protected abstract serialize(): any\n\n  protected startPayloadCompute(): IReactionDisposer {\n    return autorun(() => {\n      return this.payload\n    })\n  }\n\n  get hasErrors(): boolean {\n    return !!this.errors.save || !!this.errors.delete\n  }\n\n  get saveError(): any {\n    return this.errors.save\n  }\n\n  get deleteError(): any {\n    return this.errors.delete\n  }\n\n  // @internal\n  _onAdded(collection: TCollection, isLite: boolean): void {\n    if (this.collection && !isLite) {\n      throw new Error('Model can be in only one non \"lite\" collection')\n    }\n    if (!isLite) {\n      // @ts-expect-error - readonly property\n      this.collection = collection\n    }\n    this.onAdded(collection, isLite)\n  }\n\n  protected onAdded(collection: TCollection, isLite: boolean): void {}\n\n  // @internal\n  _onRemoved(collection: TCollection, isLite: boolean): void {\n    this.onRemoved(collection, isLite)\n    if (collection === this.collection) {\n      // @ts-expect-error - readonly property\n      this.collection = undefined\n    }\n  }\n\n  protected onRemoved(collection: TCollection, isLite: boolean): void {}\n\n  get isDeleted(): boolean {\n    return this._isDeleted\n  }\n\n  get isSyncing(): boolean {\n    return this.isSaving || this.isDeleting\n  }\n\n  get isDeleting(): boolean {\n    return this._isDeleting\n  }\n\n  get isSaving(): boolean {\n    return this._isSaving\n  }\n\n  get isDestroyed(): boolean {\n    return this._isDestroyed\n  }\n\n  // @internal\n  _onSaveStart({\n    config,\n    transportConfig,\n    token\n  }: {\n    config: SaveConfig\n    transportConfig: any\n    token: Record<string, never>\n  }): void {\n    this._isSaving = true\n    this.pendingSaveCall = {\n      token,\n      state: 'pending'\n    }\n    this.errors.save = undefined\n    this.onSaveStart({ config, transportConfig })\n  }\n\n  protected onSaveStart(data: ModelSaveStartCallback): void {}\n\n  // @internal\n  _onSaveSuccess({\n    response,\n    config,\n    transportConfig,\n    savedData,\n    token\n  }: {\n    response: any\n    config: SaveConfig\n    transportConfig: any\n    savedData: any\n    token: Record<string, never>\n  }): void {\n    if (\n      token === this.pendingSaveCall?.token ||\n      this.pendingSaveCall?.state === 'pending'\n    ) {\n      this.lastSavedData = savedData\n    }\n\n    if (token === this.pendingSaveCall?.token) {\n      this._isSaving = false\n      this.pendingSaveCall.state = 'resolved'\n    }\n\n    if (\n      this.isNew &&\n      (this.constructor as typeof Model).setIdentityFromResponse\n    ) {\n      const identityValue = this.extractIdentityValue(\n        response?.data,\n        config,\n        transportConfig\n      )\n\n      if (!identityValue) {\n        throw new IdentityError(`Can't set identity key: ${this.identityKey}`)\n      }\n\n      this.setIdentity(identityValue)\n\n      // @ts-expect-error - dynamic key access\n      this.lastSavedData[this.identityKey] = this.identity\n    }\n\n    this.onSaveSuccess({\n      config,\n      transportConfig,\n      response\n    })\n  }\n\n  protected onSaveSuccess(data: ModelSaveSuccessCallback): void {}\n\n  _onSaveError({\n    error,\n    config,\n    transportConfig,\n    token,\n    dataToSave\n  }: {\n    error: any\n    config: SaveConfig\n    transportConfig: any\n    token: Record<string, never>\n    dataToSave: any\n  }): void {\n    if (this.pendingSaveCall?.token === token) {\n      /* Only when there is no more save errors */\n      this._isSaving = false\n      this.errors.save = error\n      this.pendingSaveCall.state = 'rejected'\n    }\n    this.onSaveError({\n      error,\n      config,\n      transportConfig,\n      dataToSave\n    })\n  }\n\n  protected onSaveError(data: ModelSaveErrorCallback<Payload<this>>): void {}\n\n  protected extractIdentityValue(\n    data: any | undefined,\n    config: any, // collection save config\n    transportConfig: any // transportConfig - save\n  ): string | undefined {\n    return data && data[this.identityKey]\n  }\n\n  get identity(): string {\n    // @ts-expect-error  dynamic key access\n    return this[this.identityKey]\n  }\n\n  setIdentity(newValue: string): void {\n    // @ts-expect-error force setting identifier property on the model\n    this[this.identityKey] = newValue\n  }\n\n  get isNew(): boolean {\n    return this.modelIsNew()\n  }\n\n  protected modelIsNew(): boolean {\n    // return !this.identity\n    return this.identity === this.cid || !this.identity\n  }\n\n  // @internal\n  _onDeleteStart(data: { config: DeleteConfig; transportConfig: any }): void {\n    this._isDeleting = true\n    this.onDeleteStart(data)\n  }\n\n  protected onDeleteStart(data: ModelDeleteStartCallback<Transport>): void {}\n\n  _onDeleteSuccess(data: {\n    response: any\n    data?: any\n    config: DeleteConfig\n    transportConfig: any\n  }): void {\n    this._isDeleting = false\n    this.errors.delete = undefined\n    this._isDeleted = true\n    this.onDeleteSuccess(data)\n  }\n\n  protected onDeleteSuccess(\n    data: ModelDeleteSuccessCallback<Transport>\n  ): void {}\n\n  _onDeleteError(data: {\n    error: any\n    data?: any\n    config: DeleteConfig\n    transportConfig: any\n  }): void {\n    this.errors.delete = data.error\n    this._isDeleting = false\n    this._isDeleted = false\n\n    this.onDeleteError(data)\n  }\n\n  protected onDeleteError(data: ModelDeleteErrorCallback<Transport>): void {}\n\n  get isDirty(): boolean {\n    return this.modelIsDirty()\n  }\n\n  protected modelIsDirty(): boolean {\n    return !equal(this.lastSavedData, this.payload)\n  }\n\n  // @internal\n  destroy(): void {\n    this.onDestroy()\n    this._isDestroyed = true\n    this.payloadActionDisposer()\n  }\n\n  onDestroy(): void {}\n}\n","/* istanbul ignore file */\nimport { Collection } from '../collection/Collection'\n\nexport function wrapInArray<T = any>(item: T | T[]): T[] {\n  return Array.isArray(item) ? [...item] : [item]\n}\n\nexport function assertCollectionExists(\n  collection: unknown,\n  msg?: string\n): asserts collection is Collection<any, any, any> {\n  if (!collection) {\n    throw new Error(msg ?? 'Collection not present')\n  }\n}\n\nexport const ASYNC_STATUS = {\n  PENDING: 'PENDING',\n  RESOLVED: 'RESOLVED',\n  REJECTED: 'REJECTED',\n  IDLE: 'IDLE'\n} as const\n\nconst isObject = (value: unknown): boolean =>\n  value !== null && (typeof value === 'object' || typeof value === 'function')\n\nexport function isPromise<T>(value: Promise<T> | T): value is Promise<T> {\n  return (\n    value instanceof Promise ||\n    (isObject(value) &&\n      // @ts-expect-error - value might not be a promise\n      typeof value.then === 'function' &&\n      // @ts-expect-error - value might not be a promise\n      typeof value.catch === 'function')\n  )\n}\n\nexport function unwrapResult<T extends { error: any }>(\n  result: T\n): Omit<\n  Extract<\n    T,\n    {\n      error: 0 | '' | false | undefined | null\n    }\n  >,\n  'error'\n> {\n  const data = result\n\n  if (data.error) {\n    throw data.error\n  }\n\n  // https://stackoverflow.com/questions/69378795/narrow-down-the-return-result-based-on-a-property-value\n  const { error, ...ret } = result as Extract<\n    T,\n    { error: 0 | '' | false | undefined | null }\n  >\n\n  return ret\n}\n","import {\n  action,\n  computed,\n  IReactionDisposer,\n  makeObservable,\n  observable,\n  reaction\n} from 'mobx'\nimport { Model } from '../model/Model'\nimport {\n  AddConfig,\n  FactoryFn,\n  LiteCollectionConfig,\n  ModelInsertPosition,\n  RemoveConfig,\n  RequiredLiteCollectionConfig,\n  ResetConfig\n} from '../utils/types'\nimport { isPromise, wrapInArray } from '../utils/utils'\n\nexport class LiteCollection<\n  TModel extends Model<LiteCollection<any, any>>,\n  TFactory extends FactoryFn<TModel>\n> {\n  protected _models: TModel[] = []\n\n  protected modelByCid: Map<string, TModel> = new Map()\n\n  protected modelByIdentity: Map<string | number, TModel> = new Map()\n\n  protected config: RequiredLiteCollectionConfig\n\n  protected identityReactionByCid: Map<string, IReactionDisposer> = new Map()\n\n  constructor(protected factory: TFactory, config?: LiteCollectionConfig) {\n    this.config = {\n      add: {\n        insertPosition: 'end',\n        ...(config?.add ? config.add : undefined)\n      },\n      remove: {\n        destroy: false,\n        ...(config?.remove ? config.remove : undefined)\n      },\n      reset: {\n        destroy: false,\n        ...(config?.reset ? config.reset : undefined)\n      }\n    }\n\n    makeObservable<\n      this,\n      | 'addToCollection'\n      | 'removeFromCollection'\n      | 'modelByCid'\n      | '_models'\n      | 'modelByIdentity'\n    >(this, {\n      add: action,\n      _models: observable.shallow,\n      modelByCid: observable.shallow,\n      modelByIdentity: observable.shallow,\n      addToCollection: action,\n      removeFromCollection: action,\n      destroy: action,\n      syncing: computed,\n      deleting: computed,\n      saving: computed,\n      new: computed,\n      models: computed\n    })\n  }\n\n  getConfig(): RequiredLiteCollectionConfig {\n    return this.config\n  }\n\n  protected assertIsModel(model: unknown): asserts model is TModel {\n    /* eslint-disable-next-line no-prototype-builtins */\n    if (!Model.prototype.isPrototypeOf(model as any)) {\n      throw new Error(`model is not instance of Model class`)\n    }\n  }\n\n  push(model: TModel[]): TModel[]\n\n  push(model: TModel): TModel | undefined\n\n  push(model: TModel | TModel[]): TModel | TModel[] | undefined {\n    // https://stackoverflow.com/questions/65110771/how-to-have-functions-pass-arguments-with-the-same-overloads\n    return this.add(model as any)\n  }\n\n  add(model: TModel[]): TModel[]\n\n  add(model: TModel): TModel | undefined\n\n  add(model: TModel | TModel[]): TModel | TModel[] | undefined {\n    // @ts-expect-error - overload using overload\n    return this.addToCollection(model, { insertPosition: 'end' })\n  }\n\n  unshift(model: TModel[]): TModel[]\n\n  unshift(model: TModel): TModel | undefined\n\n  unshift(model: TModel | TModel[]): TModel | TModel[] | undefined {\n    // @ts-expect-error - overload using overload\n    return this.addToCollection(model, { insertPosition: 'start' })\n  }\n\n  addAtIndex(model: TModel[], index: number): TModel[]\n\n  addAtIndex(model: TModel, index: number): TModel | undefined\n\n  addAtIndex(\n    model: TModel | TModel[],\n    index: number\n  ): TModel | TModel[] | undefined {\n    // @ts-expect-error - overload using overload\n    return this.addToCollection(model, { insertPosition: index })\n  }\n\n  protected addToCollection(\n    model: TModel,\n    config: Omit<AddConfig, 'insertPosition'> & {\n      insertPosition?: number | ModelInsertPosition\n    }\n  ): TModel | undefined\n\n  protected addToCollection(\n    model: TModel[],\n    config: Omit<AddConfig, 'insertPosition'> & {\n      insertPosition?: number | ModelInsertPosition\n    }\n  ): TModel[]\n\n  protected addToCollection(\n    model: TModel | TModel[],\n    config: Omit<AddConfig, 'insertPosition'> & {\n      insertPosition?: number | ModelInsertPosition\n    }\n  ): TModel | TModel[] | undefined {\n    const models = wrapInArray(model)\n\n    const addConfig = {\n      ...this.config.add,\n      ...config\n    }\n    const newModels: TModel[] = []\n\n    for (const model of models) {\n      this.assertIsModel(model)\n      // model with the same id is already in the collection\n      if (!this.notPresent(model)) {\n        continue\n      }\n\n      newModels.push(model)\n\n      // const previousCollection = model.collection\n      // // model is already in some other collection\n      // if (previousCollection) {\n      //   previousCollection.removeFromCollection(model)\n      // }\n\n      this.startTracking(model)\n\n      // model._onAdded(this)\n      this.notifyAdded(model)\n\n      this.onAdded(model)\n    }\n\n    // add models to the collection\n    if (addConfig.insertPosition === 'end') {\n      this._models.push(...newModels)\n    } else if (addConfig.insertPosition === 'start') {\n      this._models.unshift(...newModels)\n    } else {\n      //number at index\n      if (\n        addConfig.insertPosition > this._models.length ||\n        addConfig.insertPosition < 0\n      ) {\n        throw new Error('insertion index out of bounds')\n      }\n      this._models.splice(addConfig.insertPosition, 0, ...newModels)\n    }\n\n    return Array.isArray(model) ? newModels : newModels[0]\n  }\n\n  protected notPresent(model: TModel): boolean {\n    const byCid = !this.modelByCid.get(model.cid)\n    let byIdentifier = false\n    const identifier = model.identity\n    // if there is an identifier value then we also need to check that\n    if (identifier) {\n      byIdentifier = !!this.modelByIdentity.get(identifier)\n    }\n\n    return byCid && !byIdentifier\n  }\n\n  protected startTracking(model: TModel): void {\n    this.modelByCid.set(model.cid, model)\n    const identifier = model.identity\n    if (identifier) {\n      this.modelByIdentity.set(identifier, model)\n    }\n\n    const idReaction = reaction(\n      () => model.identity,\n      (value) => {\n        this.modelByIdentity.set(value, model)\n      },\n      { name: `id-${model.cid}` }\n    )\n    this.identityReactionByCid.set(model.cid, idReaction)\n  }\n\n  protected stopTracking(model: TModel): void {\n    this.modelByCid.delete(model.cid)\n    this.modelByIdentity.delete(model.identity)\n\n    const reaction = this.identityReactionByCid.get(model.cid)\n    reaction ? reaction() : null\n  }\n\n  protected resolveModel(id: string): TModel | undefined {\n    const model = this.modelByIdentity.get(id)\n\n    return model || this.modelByCid.get(id)\n  }\n\n  protected resolveModels(needle: string | string[]): TModel[] {\n    const needles = wrapInArray(needle)\n    const models = []\n    for (const needle of needles) {\n      const model = this.resolveModel(needle)\n      if (model) {\n        models.push(model)\n      }\n    }\n\n    return models\n  }\n\n  create(data: Parameters<TFactory>[0]): ReturnType<TFactory> {\n    const result = this.factory(data)\n    if (isPromise(result)) {\n      result.then((model: TModel) => {\n        model.init()\n      })\n    } else {\n      result.init()\n    }\n\n    return result as ReturnType<TFactory>\n  }\n\n  getById(id: string): TModel | undefined\n\n  getById(id: string[]): TModel[] | undefined\n\n  getById(id: string | string[]): TModel | TModel[] | undefined {\n    if (Array.isArray(id)) {\n      return this.resolveModels(id)\n    }\n\n    return this.resolveModel(id)\n  }\n\n  get models(): ReadonlyArray<TModel> {\n    return this._models as ReadonlyArray<TModel>\n  }\n\n  get new(): TModel[] {\n    return this.models.filter((model) => {\n      return model.isNew\n    })\n  }\n\n  get deleted(): TModel[] {\n    return this.models.filter((model) => {\n      return model.isDeleted\n    })\n  }\n\n  get syncing(): TModel[] {\n    return this.deleting.concat(this.saving)\n  }\n\n  get deleting(): TModel[] {\n    return this._models.filter((m) => m.isDeleting)\n  }\n\n  get saving(): TModel[] {\n    return this._models.filter((m) => m.isSaving)\n  }\n\n  pop(config?: RemoveConfig): TModel | undefined {\n    if (this.models.length > 0) {\n      return this.removeFromCollection(\n        this.models[this.models.length - 1],\n        config\n      ) as TModel\n    }\n\n    return undefined\n  }\n\n  shift(config?: RemoveConfig): TModel | undefined {\n    if (this.models.length > 0) {\n      return this.removeFromCollection(this.models[0], config) as TModel\n    }\n\n    return undefined\n  }\n\n  removeAtIndex(index: number, config?: RemoveConfig): TModel | undefined {\n    if (index < 0 || index >= this._models.length) {\n      return undefined\n    }\n    const model = this._models[index]\n\n    return this.removeFromCollection(model, config) as TModel\n  }\n\n  remove(id: string, config?: RemoveConfig): TModel | undefined\n\n  remove(id: string[], config?: RemoveConfig): TModel[]\n\n  remove(\n    id: string | string[],\n    config?: RemoveConfig\n  ): TModel | TModel[] | undefined {\n    const resolved = this.resolveModels(id)\n    let final: TModel | TModel[] = resolved\n    if (!Array.isArray(id)) {\n      if (!resolved.length) {\n        return undefined\n      } else {\n        final = final[0]\n      }\n    }\n\n    // @ts-expect-error -generic type missmatch for some reason?\n    return this.removeFromCollection(final, config)\n  }\n\n  protected removeFromCollection(\n    model: TModel,\n    config?: RemoveConfig\n  ): TModel | undefined\n\n  protected removeFromCollection(\n    model: TModel[],\n    config?: RemoveConfig\n  ): TModel[]\n\n  protected removeFromCollection(\n    model: TModel | TModel[],\n    config?: RemoveConfig\n  ): TModel | TModel[] | undefined {\n    const modelCids = new Set(\n      wrapInArray(model).map((model) => {\n        return model.cid\n      })\n    )\n\n    const removed: TModel[] = []\n    const currentCount = this._models.length\n\n    const handleRemoval = (m: TModel): void => {\n      removed.push(m)\n      this.stopTracking(m)\n      this.notifyRemoved(m)\n      if (config?.destroy) {\n        m.destroy()\n      }\n      this.onRemoved(m)\n    }\n    // optimize for only one element\n    if (modelCids.size === 1) {\n      for (let i = 0; i < currentCount; i++) {\n        const model = this._models[i]\n        this.assertIsModel(model)\n        const inCollection = modelCids.has(model.cid) //model is in the collection\n        if (inCollection) {\n          this._models.splice(i, 1)\n          handleRemoval(model)\n          break\n        }\n      }\n    } else {\n      // go through whole array - todo - maybe optimize\n      const modelsToKeep = []\n      for (let i = 0; i < currentCount; i++) {\n        const model = this._models[i]\n        this.assertIsModel(model)\n        const inCollection = modelCids.has(model.cid)\n        if (inCollection) {\n          handleRemoval(model)\n        } else {\n          modelsToKeep.push(model)\n        }\n      }\n\n      this._models = modelsToKeep\n    }\n\n    return Array.isArray(model) ? removed : removed[0]\n  }\n\n  protected notifyRemoved(model: TModel): void {\n    model._onRemoved(this, true)\n  }\n\n  protected notifyAdded(model: TModel): void {\n    model._onAdded(this, true)\n  }\n\n  protected onRemoved(model: TModel): void {}\n\n  protected onAdded(model: TModel): void {}\n\n  serialize(): any {\n    return {\n      models: this.serializeModels(),\n      ...this.onSerialize()\n    }\n  }\n\n  protected serializeModels(): any[] {\n    return this._models.reduce<any[]>((arr, model) => {\n      const result = model.payload\n      if (result) {\n        arr.push(result)\n      }\n\n      return arr\n    }, [])\n  }\n\n  protected onSerialize(): any {}\n\n  protected async resetCollection<T>(\n    data?: T[],\n    config?: ResetConfig\n  ): Promise<TModel[][]> {\n    if (!data) {\n      const removed = this.removeFromCollection(this._models, config)\n\n      this.onReset([], removed)\n\n      return [[], removed]\n    }\n\n    const modelsToAdd: TModel[] = []\n    for (const modelData of data) {\n      const modifiedData = this.onModelCreateData(modelData)\n\n      if (!modifiedData) {\n        continue\n      }\n\n      const model = await this.factory(modifiedData)\n\n      modelsToAdd.push(model)\n    }\n\n    const removed = this.removeFromCollection(this._models, config)\n    const added = this.addToCollection(modelsToAdd, {\n      insertPosition: 'end'\n    })\n\n    this.onReset(added, removed)\n\n    return [added, removed]\n  }\n\n  reset<T>(modelData?: T[], config?: ResetConfig): Promise<TModel[][]> {\n    return this.resetCollection(modelData, config)\n  }\n\n  protected onReset(_added: TModel[], _removed: TModel[]): void {}\n\n  protected onModelCreateData(\n    data: Parameters<TFactory>[0]\n  ): Parameters<TFactory>[0] | void {\n    return data\n  }\n\n  destroy(): void {\n    this.onDestroy()\n\n    this.identityReactionByCid.forEach((dispose) => dispose())\n\n    this._models.forEach((model) => {\n      this.notifyRemoved(model)\n    })\n  }\n\n  protected onDestroy(): void {}\n}\n","import { action, makeObservable, observable, runInAction } from 'mobx'\nimport { IdentityError } from '../model/identity-error'\nimport { Model } from '../model/Model'\nimport { Transport } from '../transport/transport'\nimport {\n  CollectionConfig,\n  DeleteConfig,\n  DeleteErrorCallback,\n  DeleteResult,\n  DeleteStartCallback,\n  DeleteSuccessCallback,\n  FactoryFn,\n  LoadConfig,\n  LoadErrorCallback,\n  LoadResult,\n  LoadStartCallback,\n  LoadSuccessCallback,\n  RequiredCollectionConfig,\n  SaveConfig,\n  SaveErrorCallback,\n  SaveResult,\n  SaveStartCallback,\n  SaveSuccessCallback,\n  TransportDeleteConfig,\n  TransportDeleteResponse,\n  TransportLoadConfig,\n  TransportLoadResponse,\n  TransportSaveConfig,\n  TransportSaveResponse\n} from '../utils/types'\nimport { ASYNC_STATUS } from '../utils/utils'\nimport { LiteCollection } from './LiteCollection'\n\nexport class Collection<\n  TModel extends Model<Collection<any, any, any>>,\n  TFactory extends FactoryFn<TModel>,\n  TTransport extends Transport<TModel>\n> extends LiteCollection<TModel, TFactory> {\n  loadError = undefined\n\n  loadStatus: keyof typeof ASYNC_STATUS = 'IDLE'\n\n  // holds models that are immediately removed while deleting\n  _deleting: Map<string, TModel> = new Map()\n\n  // holds models that are saving but are not yet added to collection\n  protected _saving: Map<\n    string,\n    { token: Record<string, never>; model: TModel }\n  > = new Map()\n\n  protected declare config: RequiredCollectionConfig\n\n  constructor(\n    factory: TFactory,\n    protected transport: TTransport,\n    config?: CollectionConfig\n  ) {\n    super(factory, config)\n\n    this.config = {\n      ...this.config,\n      save: {\n        insertPosition: 'end',\n        addImmediately: true,\n        addOnError: true,\n        ...(config?.save ? config.save : undefined)\n      },\n      delete: {\n        remove: true,\n        destroyOnRemoval: true,\n        removeImmediately: true,\n        removeOnError: false,\n        ...(config?.delete ? config.delete : undefined)\n      },\n      load: {\n        duplicateModelStrategy: 'KEEP_NEW',\n        compareFn: () => {\n          return 'KEEP_NEW'\n        },\n        insertPosition: 'end',\n        destroyOnRemoval: true,\n        reset: false,\n        destroyOnReset: false,\n        ...(config?.load ? config.load : undefined)\n      }\n    }\n\n    makeObservable<\n      this,\n      | '_deleting'\n      | '_saving'\n      | 'onSaveStart'\n      | 'onSaveError'\n      | 'onSaveSuccess'\n      | 'onDeleteStart'\n      | 'onDeleteSuccess'\n      | 'onDeleteError'\n      | 'onLoadStart'\n      | 'onLoadSuccess'\n      | 'onLoadError'\n    >(this, {\n      save: action,\n      delete: action,\n      load: action,\n      _saving: observable.shallow,\n      _deleting: observable.shallow,\n      onSaveStart: action,\n      onSaveSuccess: action,\n      onSaveError: action,\n      onDeleteStart: action,\n      onDeleteSuccess: action,\n      onDeleteError: action,\n      onLoadStart: action,\n      onLoadSuccess: action,\n      onLoadError: action,\n      loadStatus: observable,\n      loadError: observable\n    })\n  }\n\n  getConfig(): RequiredCollectionConfig {\n    return this.config\n  }\n\n  getTransport(): TTransport {\n    return this.transport\n  }\n\n  async save(\n    model: TModel,\n    config?: SaveConfig,\n    transportConfig?: TransportSaveConfig<TTransport>\n  ): Promise<SaveResult<TModel, TTransport>> {\n    const saveConfig = {\n      ...this.config.save,\n      ...config\n    }\n\n    if (saveConfig.addImmediately) {\n      // immediately add to collection\n      this.addToCollection(model, { insertPosition: saveConfig.insertPosition })\n    } else {\n      this.assertIsModel(model)\n    }\n\n    const token = {}\n    runInAction(() => {\n      this._saving.set(model.cid, { token: token, model })\n    })\n    const dataToSave = model.payload\n    try {\n      // model take current data // todo - ovo u stvari treba da ide u transport\n\n      this.onSaveStart({\n        model,\n        config: saveConfig,\n        transportConfig\n      })\n      // model.clearSaveError()\n      model._onSaveStart({\n        config: saveConfig,\n        transportConfig,\n        token\n      })\n\n      const response = await this.callTransportSave(model, transportConfig)\n      // add it to the collection after save\n      if (!saveConfig.addImmediately) {\n        this.addToCollection(model, {\n          insertPosition: saveConfig.insertPosition\n        })\n      }\n\n      this.onSaveSuccess({\n        model,\n        response,\n        config: saveConfig,\n        transportConfig\n      })\n\n      model._onSaveSuccess({\n        response,\n        config: saveConfig,\n        transportConfig,\n        savedData: dataToSave,\n        token\n      })\n\n      return {\n        response,\n        model,\n        error: undefined\n      }\n    } catch (error) {\n      // fix closure leaks - read error stack\n      // https://twitter.com/BenLesh/status/1365056053243613185\n      error?.stack\n      // identity from the model could not be set\n      const identityError = error instanceof IdentityError\n\n      if (\n        !identityError &&\n        !saveConfig.addImmediately &&\n        saveConfig.addOnError\n      ) {\n        this.addToCollection(model, {\n          insertPosition: saveConfig.insertPosition\n        })\n      }\n\n      this.onSaveError({\n        model,\n        error,\n        config: saveConfig,\n        transportConfig\n      })\n\n      model._onSaveError({\n        error,\n        config: saveConfig,\n        transportConfig,\n        token,\n        dataToSave\n      })\n\n      return {\n        error,\n        model: undefined,\n        response: undefined\n      }\n    } finally {\n      const tokenData = this._saving.get(model.cid)\n      if (tokenData?.token === token) {\n        runInAction(() => {\n          this._saving.delete(model.cid)\n        })\n      }\n    }\n  }\n\n  protected callTransportSave(\n    model: TModel,\n    config?: TransportSaveConfig<TTransport>\n  ): Promise<TransportSaveResponse<TTransport>> {\n    return this.transport.save(model, config) as Promise<\n      TransportSaveResponse<TTransport>\n    >\n  }\n\n  protected callTransportDelete(\n    model: TModel,\n    config?: TransportDeleteConfig<TTransport>\n  ): Promise<TransportDeleteResponse<TTransport>> {\n    return this.transport.delete(model, config) as Promise<\n      TransportDeleteResponse<TTransport>\n    >\n  }\n\n  protected callTransportLoad(\n    config?: TransportLoadConfig<TTransport>\n  ): Promise<TransportLoadResponse<TTransport>> {\n    return this.transport.load(config) as Promise<\n      TransportLoadResponse<TTransport>\n    >\n  }\n\n  protected onSaveStart(data: SaveStartCallback<TModel, TTransport>): void {}\n\n  protected onSaveSuccess(\n    data: SaveSuccessCallback<TModel, TTransport>\n  ): void {}\n\n  protected onSaveError(data: SaveErrorCallback<TModel, TTransport>): void {}\n\n  get deleting(): TModel[] {\n    return [...this._deleting.values()]\n  }\n\n  get saving(): TModel[] {\n    const models: TModel[] = []\n    this._saving.forEach((data) => {\n      models.push(data.model)\n    })\n\n    return models\n  }\n\n  async delete(\n    id: string,\n    config?: DeleteConfig,\n    transportConfig?: TransportDeleteConfig<TTransport>\n  ): Promise<DeleteResult<TModel, TTransport>> {\n    const deleteConfig = {\n      ...this.config.delete,\n      ...config\n    }\n\n    const model = this.resolveModel(id)\n\n    try {\n      this.modelCanBeDeleted(model)\n    } catch (e) {\n      return {\n        error: e.message,\n        response: undefined,\n        model: undefined\n      }\n    }\n\n    if (deleteConfig.remove && deleteConfig.removeImmediately) {\n      this.removeFromCollection(model, {\n        destroy: deleteConfig.destroyOnRemoval\n      })\n    }\n    try {\n      this._deleting.set(model.cid, model)\n\n      this.onDeleteStart({\n        model,\n        config: deleteConfig,\n        transportConfig: transportConfig\n      })\n      model._onDeleteStart({\n        config: deleteConfig,\n        transportConfig: transportConfig\n      })\n\n      const response = await this.callTransportDelete(model, transportConfig)\n\n      if (deleteConfig.remove && !deleteConfig.removeImmediately) {\n        this.removeFromCollection(model, {\n          destroy: deleteConfig.destroyOnRemoval\n        })\n      }\n      this.onDeleteSuccess({\n        model,\n        response,\n        config: deleteConfig,\n        transportConfig: transportConfig\n      })\n      model._onDeleteSuccess({\n        response,\n        config: deleteConfig,\n        transportConfig: transportConfig\n      })\n\n      return {\n        response,\n        model,\n        error: undefined\n      }\n    } catch (error) {\n      if (\n        deleteConfig.remove &&\n        !deleteConfig.removeImmediately &&\n        deleteConfig.removeOnError\n      ) {\n        this.removeFromCollection(model, {\n          destroy: deleteConfig.destroyOnRemoval\n        })\n      }\n      this.onDeleteError({\n        model,\n        error,\n        config: deleteConfig,\n        transportConfig: transportConfig\n      })\n      model._onDeleteError({\n        error,\n        config: deleteConfig,\n        data: error?.data,\n        transportConfig: transportConfig\n      })\n\n      // throw error\n      return {\n        response: undefined,\n        model: undefined,\n        error\n      }\n    } finally {\n      runInAction(() => {\n        this._deleting.delete(model.cid)\n      })\n    }\n  }\n\n  protected modelCanBeDeleted(model?: TModel): asserts model is TModel {\n    this.assertModelIsExists(model)\n\n    if (model.isDeleted) {\n      throw new Error('Model is deleted')\n    }\n    if (model.isDeleting) {\n      throw new Error('Model is in the process of deleting')\n    }\n  }\n\n  protected assertModelIsExists(model?: TModel): asserts model {\n    if (!model) {\n      throw new Error('Model is not in the collection')\n    }\n  }\n\n  protected onDeleteStart(\n    data: DeleteStartCallback<TModel, TTransport>\n  ): void {}\n\n  protected onDeleteSuccess(\n    data: DeleteSuccessCallback<TModel, TTransport>\n  ): void {}\n\n  protected onDeleteError(\n    _data: DeleteErrorCallback<TModel, TTransport>\n  ): void {}\n\n  async load(\n    config?: LoadConfig,\n    transportConfig?: TransportLoadConfig<TTransport>\n  ): Promise<LoadResult<TModel, TTransport>> {\n    this.loadError = undefined\n\n    const loadConfig = {\n      ...this.config.load,\n      ...config\n    }\n\n    try {\n      this.loadStatus = 'PENDING'\n      this.onLoadStart({\n        config: loadConfig,\n        transportConfig\n      })\n\n      const response = await this.callTransportLoad(transportConfig)\n\n      runInAction(() => {\n        this.loadStatus = 'RESOLVED'\n      })\n\n      // run reset instead of the rest of the load function\n      if (loadConfig.reset) {\n        const [added, removed] = await this.resetCollection(response.data, {\n          destroy: loadConfig.destroyOnReset\n        })\n\n        this.onLoadSuccess({\n          config: loadConfig,\n          transportConfig,\n          response,\n          added,\n          removed\n        })\n\n        return {\n          response,\n          added,\n          removed,\n          error: undefined\n        }\n      }\n\n      const modelsToAdd: TModel[] = []\n      const modelsToRemove: string[] = []\n\n      for (const modelData of response.data) {\n        const modifiedData = this.onModelCreateData(modelData)\n\n        if (!modifiedData) {\n          continue\n        }\n        const model = await this.factory(modifiedData)\n\n        if (this.notPresent(model)) {\n          modelsToAdd.push(model)\n        } else {\n          // model is already present\n          // resolve if it should be added\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const oldModel = this.modelByIdentity.get(model.identity)!\n\n          const compareResult = loadConfig.compareFn(model, oldModel)\n\n          switch (loadConfig.duplicateModelStrategy) {\n            case 'KEEP_NEW':\n              modelsToRemove.push(oldModel.cid)\n              modelsToAdd.push(model)\n              break\n            case 'COMPARE':\n              switch (compareResult) {\n                case 'KEEP_NEW':\n                  modelsToAdd.push(model)\n                  modelsToRemove.push(oldModel.cid)\n                  break\n\n                case 'KEEP_OLD':\n                  break\n\n                case 'KEEP_BOTH':\n                  if (!this.notPresent(model)) {\n                    throw new Error('New model has a non unique identity')\n                  }\n                  modelsToAdd.push(model)\n                  break\n                default:\n                  throw new Error('Invalid compare result')\n              }\n          }\n        }\n      } //end for\n\n      const removed = this.remove(modelsToRemove, {\n        destroy: loadConfig.destroyOnRemoval\n      })\n      const added = this.addToCollection(modelsToAdd, {\n        insertPosition: loadConfig.insertPosition\n      })\n\n      // this.loaded = true\n      // this.load\n      this.onLoadSuccess({\n        config: loadConfig,\n        transportConfig,\n        response,\n        added,\n        removed\n      })\n\n      return {\n        response,\n        added,\n        removed,\n        error: undefined\n      }\n    } catch (error) {\n      // fix closure leaks - read error stack\n      // https://twitter.com/BenLesh/status/1365056053243613185\n      error?.stack\n      runInAction(() => {\n        this.loadError = error\n        this.loadStatus = 'REJECTED'\n      })\n\n      this.onLoadError({\n        config: loadConfig,\n        transportConfig,\n        error\n      })\n\n      return {\n        error,\n        response: undefined,\n        added: undefined,\n        removed: undefined\n      }\n    }\n  }\n\n  protected onLoadStart(data: LoadStartCallback<TModel, TTransport>): void {}\n\n  protected onLoadSuccess(\n    data: LoadSuccessCallback<TModel, TTransport>\n  ): void {}\n\n  protected onLoadError(data: LoadErrorCallback<TModel, TTransport>): void {}\n\n  protected override notifyAdded(model: TModel): void {\n    model._onAdded(this, false)\n  }\n\n  protected override notifyRemoved(model: TModel): void {\n    model._onRemoved(this, false)\n  }\n\n  override destroy(): void {\n    super.destroy()\n\n    this._models.forEach((model) => {\n      model.destroy()\n    })\n    this._models = []\n  }\n}\n","import type { Model } from '../model/Model'\n\nexport interface Transport<TModel extends Model<any> = Model<any>, TDTO = any> {\n  load(config?: any): Promise<{ data: TDTO[] }>\n\n  save(model: TModel, config?: any): Promise<{ data?: any } | void>\n\n  delete(model: TModel, config?: any): Promise<{ data?: any } | void>\n}\n\nexport class StubTransport<TModel extends Model<any> = Model<any>, TDTO = any>\n  implements Transport<TModel, TDTO>\n{\n  load(): Promise<{ data: TDTO[] }> {\n    return Promise.resolve({ data: [] })\n  }\n\n  save(m: TModel): Promise<void> {\n    return Promise.resolve()\n  }\n\n  delete(): Promise<void> {\n    return Promise.resolve()\n  }\n}\n"],"names":["IdentityError","message","_this","name","Error","Model","collection","cid","errors","save","delete","_isDeleted","_isSaving","_isDeleting","ignoreChange","_isDestroyed","payloadActionDisposer","initialized","pendingSaveCall","lastSavedData","undefined","this","nanoid","makeObservable","init","action","observable","isDeleted","computed","isSaving","isDeleting","isDirty","isDestroyed","isSyncing","isNew","computePayload","struct","payload","setIdentity","identity","hasErrors","saveError","deleteError","_onAdded","_onRemoved","_onSaveStart","_onSaveSuccess","_onSaveError","_onDeleteError","_onDeleteStart","_onDeleteSuccess","destroy","startPayloadCompute","autorun","isLite","onAdded","onRemoved","config","transportConfig","token","state","onSaveStart","data","response","_this$pendingSaveCall","savedData","_this$pendingSaveCall3","constructor","setIdentityFromResponse","identityValue","extractIdentityValue","identityKey","onSaveSuccess","error","dataToSave","onSaveError","newValue","modelIsNew","onDeleteStart","onDeleteSuccess","onDeleteError","modelIsDirty","equal","onDestroy","serialize","wrapInArray","item","Array","isArray","value","v","onFulfilled","result","e","LiteCollection","factory","_models","modelByCid","Map","modelByIdentity","identityReactionByCid","add","insertPosition","remove","reset","shallow","addToCollection","removeFromCollection","syncing","deleting","saving","new","models","getConfig","assertIsModel","model","prototype","isPrototypeOf","push","unshift","addAtIndex","index","addConfig","newModels","notPresent","startTracking","notifyAdded","length","splice","byCid","get","byIdentifier","identifier","set","idReaction","reaction","stopTracking","resolveModel","id","resolveModels","needle","create","Promise","isObject","then","getById","pop","shift","removeAtIndex","resolved","final","modelCids","Set","map","removed","currentCount","handleRemoval","m","_this2","notifyRemoved","size","i","has","modelsToKeep","serializeModels","onSerialize","reduce","arr","resetCollection","_this4","added","modelsToAdd","onReset","pact","_settle","reject","modelData","modifiedData","onModelCreateData","_added","_removed","forEach","dispose","_this5","filter","concat","onRejected","callback","Collection","transport","loadError","loadStatus","_deleting","_saving","addImmediately","addOnError","destroyOnRemoval","removeImmediately","removeOnError","load","duplicateModelStrategy","compareFn","destroyOnReset","onLoadStart","onLoadSuccess","onLoadError","getTransport","saveConfig","_this3","runInAction","callTransportSave","tokenData","callTransportDelete","callTransportLoad","deleteConfig","modelCanBeDeleted","assertModelIsExists","_data","_this7","loadConfig","modelsToRemove","target","array","_isSettledPact","oldModel","compareResult","_LiteCollection","values","StubTransport","resolve","PENDING","RESOLVED","REJECTED","IDLE"],"mappings":"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"}
{"version":3,"file":"core.esm.js","sources":["../../src/model/identity-error.ts","../../src/model/Model.ts","../../src/utils/utils.ts","../../src/collection/Collection.ts","../../src/collection/LiteCollection.ts","../../src/transport/transport.ts"],"sourcesContent":["export class IdentityError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'Identity Error'\n  }\n}\n","import equal from 'fast-deep-equal'\nimport {\n  action,\n  autorun,\n  computed,\n  IReactionDisposer,\n  makeObservable,\n  observable\n} from 'mobx'\nimport { nanoid } from 'nanoid/non-secure'\nimport { LiteCollection } from '../collection/LiteCollection'\nimport { Transport } from '../transport/transport'\nimport {\n  DeleteConfig,\n  ModelDeleteErrorCallback,\n  ModelDeleteStartCallback,\n  ModelDeleteSuccessCallback,\n  ModelSaveErrorCallback,\n  ModelSaveStartCallback,\n  ModelSaveSuccessCallback,\n  ModelTransportErrors,\n  SaveConfig\n} from '../utils/types'\nimport { IdentityError } from './identity-error'\n\n// @ts-expect-error: using return type on a protected method\ntype Payload<T extends Model> = ReturnType<T['serialize']>\n\nexport abstract class Model<\n  TCollection extends LiteCollection<any, any> = LiteCollection<any, any>\n> {\n  static identityKey = 'cid'\n\n  static setIdentityFromResponse = false\n\n  readonly collection: TCollection | undefined\n\n  readonly cid: string\n\n  protected errors: ModelTransportErrors = {\n    save: null,\n    delete: null\n  }\n\n  protected _isDeleted = false\n\n  protected _isSaving = false\n\n  protected _isDeleting = false\n\n  protected ignoreChange = false\n\n  protected _isDestroyed = false\n\n  protected payloadActionDisposer!: IReactionDisposer\n\n  protected initialized = false\n\n  protected pendingSaveCall:\n    | {\n        token: Record<string, never>\n        state: 'pending' | 'resolved' | 'rejected'\n      }\n    | undefined\n\n  lastSavedData: Payload<this> | undefined = undefined\n\n  get identityKey(): string {\n    return (this.constructor as typeof Model).identityKey\n  }\n\n  constructor() {\n    this.cid = nanoid()\n\n    makeObservable<\n      this,\n      | '_isDeleted'\n      | '_isSaving'\n      | '_isDestroyed'\n      | '_isDeleting'\n      | 'errors'\n      | 'computePayload'\n      | 'lastSavedData'\n    >(this, {\n      init: action,\n      _isDeleted: observable,\n      isDeleted: computed,\n\n      _isSaving: observable,\n      isSaving: computed,\n\n      _isDeleting: observable,\n      isDeleting: computed,\n\n      isDirty: computed,\n      _isDestroyed: observable,\n      isDestroyed: computed,\n\n      isSyncing: computed,\n      lastSavedData: observable,\n\n      isNew: computed,\n\n      computePayload: computed.struct,\n      payload: computed,\n\n      setIdentity: action,\n      identity: computed,\n      hasErrors: computed,\n      errors: observable,\n      saveError: computed,\n      deleteError: computed,\n      _onAdded: action,\n      _onRemoved: action,\n\n      _onSaveStart: action,\n      _onSaveSuccess: action,\n      _onSaveError: action,\n      _onDeleteError: action,\n      _onDeleteStart: action,\n      _onDeleteSuccess: action,\n      destroy: action\n    })\n  }\n\n  // @internal\n  init(): void {\n    if (this.initialized) return\n    this.payloadActionDisposer = this.startPayloadCompute()\n    this.lastSavedData = this.payload\n    this.initialized = true\n  }\n\n  // https://alexhisen.gitbook.io/mobx-recipes/use-computedstruct-for-computed-objects\n  get payload(): Payload<this> {\n    return this.computePayload\n  }\n\n  //computed struct\n  protected get computePayload(): Payload<this> {\n    return this.serialize()\n  }\n\n  protected abstract serialize(): any\n\n  protected startPayloadCompute(): IReactionDisposer {\n    return autorun(() => {\n      return this.payload\n    })\n  }\n\n  get hasErrors(): boolean {\n    return !!this.errors.save || !!this.errors.delete\n  }\n\n  get saveError(): any {\n    return this.errors.save\n  }\n\n  get deleteError(): any {\n    return this.errors.delete\n  }\n\n  // @internal\n  _onAdded(collection: TCollection, isLite: boolean): void {\n    if (this.collection && !isLite) {\n      throw new Error('Model can be in only one non \"lite\" collection')\n    }\n    if (!isLite) {\n      // @ts-expect-error - readonly property\n      this.collection = collection\n    }\n    this.onAdded(collection, isLite)\n  }\n\n  protected onAdded(collection: TCollection, isLite: boolean): void {}\n\n  // @internal\n  _onRemoved(collection: TCollection, isLite: boolean): void {\n    this.onRemoved(collection, isLite)\n    if (collection === this.collection) {\n      // @ts-expect-error - readonly property\n      this.collection = undefined\n    }\n  }\n\n  protected onRemoved(collection: TCollection, isLite: boolean): void {}\n\n  get isDeleted(): boolean {\n    return this._isDeleted\n  }\n\n  get isSyncing(): boolean {\n    return this.isSaving || this.isDeleting\n  }\n\n  get isDeleting(): boolean {\n    return this._isDeleting\n  }\n\n  get isSaving(): boolean {\n    return this._isSaving\n  }\n\n  get isDestroyed(): boolean {\n    return this._isDestroyed\n  }\n\n  // @internal\n  _onSaveStart({\n    config,\n    transportConfig,\n    token\n  }: {\n    config: SaveConfig\n    transportConfig: any\n    token: Record<string, never>\n  }): void {\n    this._isSaving = true\n    this.pendingSaveCall = {\n      token,\n      state: 'pending'\n    }\n    this.errors.save = undefined\n    this.onSaveStart({ config, transportConfig })\n  }\n\n  protected onSaveStart(data: ModelSaveStartCallback): void {}\n\n  // @internal\n  _onSaveSuccess({\n    response,\n    config,\n    transportConfig,\n    savedData,\n    token\n  }: {\n    response: any\n    config: SaveConfig\n    transportConfig: any\n    savedData: any\n    token: Record<string, never>\n  }): void {\n    if (\n      token === this.pendingSaveCall?.token ||\n      this.pendingSaveCall?.state === 'pending'\n    ) {\n      this.lastSavedData = savedData\n    }\n\n    if (token === this.pendingSaveCall?.token) {\n      this._isSaving = false\n      this.pendingSaveCall.state = 'resolved'\n    }\n\n    if (\n      this.isNew &&\n      (this.constructor as typeof Model).setIdentityFromResponse\n    ) {\n      const identityValue = this.extractIdentityValue(\n        response?.data,\n        config,\n        transportConfig\n      )\n\n      if (!identityValue) {\n        throw new IdentityError(`Can't set identity key: ${this.identityKey}`)\n      }\n\n      this.setIdentity(identityValue)\n\n      // @ts-expect-error - dynamic key access\n      this.lastSavedData[this.identityKey] = this.identity\n    }\n\n    this.onSaveSuccess({\n      config,\n      transportConfig,\n      response\n    })\n  }\n\n  protected onSaveSuccess(data: ModelSaveSuccessCallback): void {}\n\n  _onSaveError({\n    error,\n    config,\n    transportConfig,\n    token,\n    dataToSave\n  }: {\n    error: any\n    config: SaveConfig\n    transportConfig: any\n    token: Record<string, never>\n    dataToSave: any\n  }): void {\n    if (this.pendingSaveCall?.token === token) {\n      /* Only when there is no more save errors */\n      this._isSaving = false\n      this.errors.save = error\n      this.pendingSaveCall.state = 'rejected'\n    }\n    this.onSaveError({\n      error,\n      config,\n      transportConfig,\n      dataToSave\n    })\n  }\n\n  protected onSaveError(data: ModelSaveErrorCallback<Payload<this>>): void {}\n\n  protected extractIdentityValue(\n    data: any | undefined,\n    config: any, // collection save config\n    transportConfig: any // transportConfig - save\n  ): string | undefined {\n    return data && data[this.identityKey]\n  }\n\n  get identity(): string {\n    // @ts-expect-error  dynamic key access\n    return this[this.identityKey]\n  }\n\n  setIdentity(newValue: string): void {\n    // @ts-expect-error force setting identifier property on the model\n    this[this.identityKey] = newValue\n  }\n\n  get isNew(): boolean {\n    return this.modelIsNew()\n  }\n\n  protected modelIsNew(): boolean {\n    // return !this.identity\n    return this.identity === this.cid || !this.identity\n  }\n\n  // @internal\n  _onDeleteStart(data: { config: DeleteConfig; transportConfig: any }): void {\n    this._isDeleting = true\n    this.onDeleteStart(data)\n  }\n\n  protected onDeleteStart(data: ModelDeleteStartCallback<Transport>): void {}\n\n  _onDeleteSuccess(data: {\n    response: any\n    data?: any\n    config: DeleteConfig\n    transportConfig: any\n  }): void {\n    this._isDeleting = false\n    this.errors.delete = undefined\n    this._isDeleted = true\n    this.onDeleteSuccess(data)\n  }\n\n  protected onDeleteSuccess(\n    data: ModelDeleteSuccessCallback<Transport>\n  ): void {}\n\n  _onDeleteError(data: {\n    error: any\n    data?: any\n    config: DeleteConfig\n    transportConfig: any\n  }): void {\n    this.errors.delete = data.error\n    this._isDeleting = false\n    this._isDeleted = false\n\n    this.onDeleteError(data)\n  }\n\n  protected onDeleteError(data: ModelDeleteErrorCallback<Transport>): void {}\n\n  get isDirty(): boolean {\n    return this.modelIsDirty()\n  }\n\n  protected modelIsDirty(): boolean {\n    return !equal(this.lastSavedData, this.payload)\n  }\n\n  // @internal\n  destroy(): void {\n    this.onDestroy()\n    this._isDestroyed = true\n    this.payloadActionDisposer()\n  }\n\n  onDestroy(): void {}\n}\n","/* istanbul ignore file */\nimport { Collection } from '../collection/Collection'\n\nexport function wrapInArray<T = any>(item: T | T[]): T[] {\n  return Array.isArray(item) ? [...item] : [item]\n}\n\nexport function assertCollectionExists(\n  collection: unknown,\n  msg?: string\n): asserts collection is Collection<any, any, any> {\n  if (!collection) {\n    throw new Error(msg ?? 'Collection not present')\n  }\n}\n\nexport const ASYNC_STATUS = {\n  PENDING: 'PENDING',\n  RESOLVED: 'RESOLVED',\n  REJECTED: 'REJECTED',\n  IDLE: 'IDLE'\n} as const\n\nconst isObject = (value: unknown): boolean =>\n  value !== null && (typeof value === 'object' || typeof value === 'function')\n\nexport function isPromise<T>(value: Promise<T> | T): value is Promise<T> {\n  return (\n    value instanceof Promise ||\n    (isObject(value) &&\n      // @ts-expect-error - value might not be a promise\n      typeof value.then === 'function' &&\n      // @ts-expect-error - value might not be a promise\n      typeof value.catch === 'function')\n  )\n}\n\nexport function unwrapResult<T extends { error: any }>(\n  result: T\n): Omit<\n  Extract<\n    T,\n    {\n      error: 0 | '' | false | undefined | null\n    }\n  >,\n  'error'\n> {\n  const data = result\n\n  if (data.error) {\n    throw data.error\n  }\n\n  // https://stackoverflow.com/questions/69378795/narrow-down-the-return-result-based-on-a-property-value\n  const { error, ...ret } = result as Extract<\n    T,\n    { error: 0 | '' | false | undefined | null }\n  >\n\n  return ret\n}\n","import { action, makeObservable, observable, runInAction } from 'mobx'\nimport { IdentityError } from '../model/identity-error'\nimport { Model } from '../model/Model'\nimport { Transport } from '../transport/transport'\nimport {\n  CollectionConfig,\n  DeleteConfig,\n  DeleteErrorCallback,\n  DeleteResult,\n  DeleteStartCallback,\n  DeleteSuccessCallback,\n  FactoryFn,\n  LoadConfig,\n  LoadErrorCallback,\n  LoadResult,\n  LoadStartCallback,\n  LoadSuccessCallback,\n  RequiredCollectionConfig,\n  SaveConfig,\n  SaveErrorCallback,\n  SaveResult,\n  SaveStartCallback,\n  SaveSuccessCallback,\n  TransportDeleteConfig,\n  TransportDeleteResponse,\n  TransportLoadConfig,\n  TransportLoadResponse,\n  TransportSaveConfig,\n  TransportSaveResponse\n} from '../utils/types'\nimport { ASYNC_STATUS } from '../utils/utils'\nimport { LiteCollection } from './LiteCollection'\n\nexport class Collection<\n  TModel extends Model<Collection<any, any, any>>,\n  TFactory extends FactoryFn<TModel>,\n  TTransport extends Transport<TModel>\n> extends LiteCollection<TModel, TFactory> {\n  loadError = undefined\n\n  loadStatus: keyof typeof ASYNC_STATUS = 'IDLE'\n\n  // holds models that are immediately removed while deleting\n  _deleting: Map<string, TModel> = new Map()\n\n  // holds models that are saving but are not yet added to collection\n  protected _saving: Map<\n    string,\n    { token: Record<string, never>; model: TModel }\n  > = new Map()\n\n  protected declare config: RequiredCollectionConfig\n\n  constructor(\n    factory: TFactory,\n    protected transport: TTransport,\n    config?: CollectionConfig\n  ) {\n    super(factory, config)\n\n    this.config = {\n      ...this.config,\n      save: {\n        insertPosition: 'end',\n        addImmediately: true,\n        addOnError: true,\n        ...(config?.save ? config.save : undefined)\n      },\n      delete: {\n        remove: true,\n        destroyOnRemoval: true,\n        removeImmediately: true,\n        removeOnError: false,\n        ...(config?.delete ? config.delete : undefined)\n      },\n      load: {\n        duplicateModelStrategy: 'KEEP_NEW',\n        compareFn: () => {\n          return 'KEEP_NEW'\n        },\n        insertPosition: 'end',\n        destroyOnRemoval: true,\n        reset: false,\n        destroyOnReset: false,\n        ...(config?.load ? config.load : undefined)\n      }\n    }\n\n    makeObservable<\n      this,\n      | '_deleting'\n      | '_saving'\n      | 'onSaveStart'\n      | 'onSaveError'\n      | 'onSaveSuccess'\n      | 'onDeleteStart'\n      | 'onDeleteSuccess'\n      | 'onDeleteError'\n      | 'onLoadStart'\n      | 'onLoadSuccess'\n      | 'onLoadError'\n    >(this, {\n      save: action,\n      delete: action,\n      load: action,\n      _saving: observable.shallow,\n      _deleting: observable.shallow,\n      onSaveStart: action,\n      onSaveSuccess: action,\n      onSaveError: action,\n      onDeleteStart: action,\n      onDeleteSuccess: action,\n      onDeleteError: action,\n      onLoadStart: action,\n      onLoadSuccess: action,\n      onLoadError: action,\n      loadStatus: observable,\n      loadError: observable\n    })\n  }\n\n  getConfig(): RequiredCollectionConfig {\n    return this.config\n  }\n\n  getTransport(): TTransport {\n    return this.transport\n  }\n\n  async save(\n    model: TModel,\n    config?: SaveConfig,\n    transportConfig?: TransportSaveConfig<TTransport>\n  ): Promise<SaveResult<TModel, TTransport>> {\n    const saveConfig = {\n      ...this.config.save,\n      ...config\n    }\n\n    if (saveConfig.addImmediately) {\n      // immediately add to collection\n      this.addToCollection(model, { insertPosition: saveConfig.insertPosition })\n    } else {\n      this.assertIsModel(model)\n    }\n\n    const token = {}\n    runInAction(() => {\n      this._saving.set(model.cid, { token: token, model })\n    })\n    const dataToSave = model.payload\n    try {\n      // model take current data // todo - ovo u stvari treba da ide u transport\n\n      this.onSaveStart({\n        model,\n        config: saveConfig,\n        transportConfig\n      })\n      // model.clearSaveError()\n      model._onSaveStart({\n        config: saveConfig,\n        transportConfig,\n        token\n      })\n\n      const response = await this.callTransportSave(model, transportConfig)\n      // add it to the collection after save\n      if (!saveConfig.addImmediately) {\n        this.addToCollection(model, {\n          insertPosition: saveConfig.insertPosition\n        })\n      }\n\n      this.onSaveSuccess({\n        model,\n        response,\n        config: saveConfig,\n        transportConfig\n      })\n\n      model._onSaveSuccess({\n        response,\n        config: saveConfig,\n        transportConfig,\n        savedData: dataToSave,\n        token\n      })\n\n      return {\n        response,\n        model,\n        error: undefined\n      }\n    } catch (error) {\n      // fix closure leaks - read error stack\n      // https://twitter.com/BenLesh/status/1365056053243613185\n      error?.stack\n      // identity from the model could not be set\n      const identityError = error instanceof IdentityError\n\n      if (\n        !identityError &&\n        !saveConfig.addImmediately &&\n        saveConfig.addOnError\n      ) {\n        this.addToCollection(model, {\n          insertPosition: saveConfig.insertPosition\n        })\n      }\n\n      this.onSaveError({\n        model,\n        error,\n        config: saveConfig,\n        transportConfig\n      })\n\n      model._onSaveError({\n        error,\n        config: saveConfig,\n        transportConfig,\n        token,\n        dataToSave\n      })\n\n      return {\n        error,\n        model: undefined,\n        response: undefined\n      }\n    } finally {\n      const tokenData = this._saving.get(model.cid)\n      if (tokenData?.token === token) {\n        runInAction(() => {\n          this._saving.delete(model.cid)\n        })\n      }\n    }\n  }\n\n  protected callTransportSave(\n    model: TModel,\n    config?: TransportSaveConfig<TTransport>\n  ): Promise<TransportSaveResponse<TTransport>> {\n    return this.transport.save(model, config) as Promise<\n      TransportSaveResponse<TTransport>\n    >\n  }\n\n  protected callTransportDelete(\n    model: TModel,\n    config?: TransportDeleteConfig<TTransport>\n  ): Promise<TransportDeleteResponse<TTransport>> {\n    return this.transport.delete(model, config) as Promise<\n      TransportDeleteResponse<TTransport>\n    >\n  }\n\n  protected callTransportLoad(\n    config?: TransportLoadConfig<TTransport>\n  ): Promise<TransportLoadResponse<TTransport>> {\n    return this.transport.load(config) as Promise<\n      TransportLoadResponse<TTransport>\n    >\n  }\n\n  protected onSaveStart(data: SaveStartCallback<TModel, TTransport>): void {}\n\n  protected onSaveSuccess(\n    data: SaveSuccessCallback<TModel, TTransport>\n  ): void {}\n\n  protected onSaveError(data: SaveErrorCallback<TModel, TTransport>): void {}\n\n  get deleting(): TModel[] {\n    return [...this._deleting.values()]\n  }\n\n  get saving(): TModel[] {\n    const models: TModel[] = []\n    this._saving.forEach((data) => {\n      models.push(data.model)\n    })\n\n    return models\n  }\n\n  async delete(\n    id: string,\n    config?: DeleteConfig,\n    transportConfig?: TransportDeleteConfig<TTransport>\n  ): Promise<DeleteResult<TModel, TTransport>> {\n    const deleteConfig = {\n      ...this.config.delete,\n      ...config\n    }\n\n    const model = this.resolveModel(id)\n\n    try {\n      this.modelCanBeDeleted(model)\n    } catch (e) {\n      return {\n        error: e.message,\n        response: undefined,\n        model: undefined\n      }\n    }\n\n    if (deleteConfig.remove && deleteConfig.removeImmediately) {\n      this.removeFromCollection(model, {\n        destroy: deleteConfig.destroyOnRemoval\n      })\n    }\n    try {\n      this._deleting.set(model.cid, model)\n\n      this.onDeleteStart({\n        model,\n        config: deleteConfig,\n        transportConfig: transportConfig\n      })\n      model._onDeleteStart({\n        config: deleteConfig,\n        transportConfig: transportConfig\n      })\n\n      const response = await this.callTransportDelete(model, transportConfig)\n\n      if (deleteConfig.remove && !deleteConfig.removeImmediately) {\n        this.removeFromCollection(model, {\n          destroy: deleteConfig.destroyOnRemoval\n        })\n      }\n      this.onDeleteSuccess({\n        model,\n        response,\n        config: deleteConfig,\n        transportConfig: transportConfig\n      })\n      model._onDeleteSuccess({\n        response,\n        config: deleteConfig,\n        transportConfig: transportConfig\n      })\n\n      return {\n        response,\n        model,\n        error: undefined\n      }\n    } catch (error) {\n      if (\n        deleteConfig.remove &&\n        !deleteConfig.removeImmediately &&\n        deleteConfig.removeOnError\n      ) {\n        this.removeFromCollection(model, {\n          destroy: deleteConfig.destroyOnRemoval\n        })\n      }\n      this.onDeleteError({\n        model,\n        error,\n        config: deleteConfig,\n        transportConfig: transportConfig\n      })\n      model._onDeleteError({\n        error,\n        config: deleteConfig,\n        data: error?.data,\n        transportConfig: transportConfig\n      })\n\n      // throw error\n      return {\n        response: undefined,\n        model: undefined,\n        error\n      }\n    } finally {\n      runInAction(() => {\n        this._deleting.delete(model.cid)\n      })\n    }\n  }\n\n  protected modelCanBeDeleted(model?: TModel): asserts model is TModel {\n    this.assertModelIsExists(model)\n\n    if (model.isDeleted) {\n      throw new Error('Model is deleted')\n    }\n    if (model.isDeleting) {\n      throw new Error('Model is in the process of deleting')\n    }\n  }\n\n  protected assertModelIsExists(model?: TModel): asserts model {\n    if (!model) {\n      throw new Error('Model is not in the collection')\n    }\n  }\n\n  protected onDeleteStart(\n    data: DeleteStartCallback<TModel, TTransport>\n  ): void {}\n\n  protected onDeleteSuccess(\n    data: DeleteSuccessCallback<TModel, TTransport>\n  ): void {}\n\n  protected onDeleteError(\n    _data: DeleteErrorCallback<TModel, TTransport>\n  ): void {}\n\n  async load(\n    config?: LoadConfig,\n    transportConfig?: TransportLoadConfig<TTransport>\n  ): Promise<LoadResult<TModel, TTransport>> {\n    this.loadError = undefined\n\n    const loadConfig = {\n      ...this.config.load,\n      ...config\n    }\n\n    try {\n      this.loadStatus = 'PENDING'\n      this.onLoadStart({\n        config: loadConfig,\n        transportConfig\n      })\n\n      const response = await this.callTransportLoad(transportConfig)\n\n      runInAction(() => {\n        this.loadStatus = 'RESOLVED'\n      })\n\n      // run reset instead of the rest of the load function\n      if (loadConfig.reset) {\n        const [added, removed] = await this.resetCollection(response.data, {\n          destroy: loadConfig.destroyOnReset\n        })\n\n        this.onLoadSuccess({\n          config: loadConfig,\n          transportConfig,\n          response,\n          added,\n          removed\n        })\n\n        return {\n          response,\n          added,\n          removed,\n          error: undefined\n        }\n      }\n\n      const modelsToAdd: TModel[] = []\n      const modelsToRemove: string[] = []\n\n      for (const modelData of response.data) {\n        const modifiedData = this.onModelCreateData(modelData)\n\n        if (!modifiedData) {\n          continue\n        }\n        const model = await this.factory(modifiedData)\n\n        if (this.notPresent(model)) {\n          modelsToAdd.push(model)\n        } else {\n          // model is already present\n          // resolve if it should be added\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const oldModel = this.modelByIdentity.get(model.identity)!\n\n          const compareResult = loadConfig.compareFn(model, oldModel)\n\n          switch (loadConfig.duplicateModelStrategy) {\n            case 'KEEP_NEW':\n              modelsToRemove.push(oldModel.cid)\n              modelsToAdd.push(model)\n              break\n            case 'COMPARE':\n              switch (compareResult) {\n                case 'KEEP_NEW':\n                  modelsToAdd.push(model)\n                  modelsToRemove.push(oldModel.cid)\n                  break\n\n                case 'KEEP_OLD':\n                  break\n\n                case 'KEEP_BOTH':\n                  if (!this.notPresent(model)) {\n                    throw new Error('New model has a non unique identity')\n                  }\n                  modelsToAdd.push(model)\n                  break\n                default:\n                  throw new Error('Invalid compare result')\n              }\n          }\n        }\n      } //end for\n\n      const removed = this.remove(modelsToRemove, {\n        destroy: loadConfig.destroyOnRemoval\n      })\n      const added = this.addToCollection(modelsToAdd, {\n        insertPosition: loadConfig.insertPosition\n      })\n\n      // this.loaded = true\n      // this.load\n      this.onLoadSuccess({\n        config: loadConfig,\n        transportConfig,\n        response,\n        added,\n        removed\n      })\n\n      return {\n        response,\n        added,\n        removed,\n        error: undefined\n      }\n    } catch (error) {\n      // fix closure leaks - read error stack\n      // https://twitter.com/BenLesh/status/1365056053243613185\n      error?.stack\n      runInAction(() => {\n        this.loadError = error\n        this.loadStatus = 'REJECTED'\n      })\n\n      this.onLoadError({\n        config: loadConfig,\n        transportConfig,\n        error\n      })\n\n      return {\n        error,\n        response: undefined,\n        added: undefined,\n        removed: undefined\n      }\n    }\n  }\n\n  protected onLoadStart(data: LoadStartCallback<TModel, TTransport>): void {}\n\n  protected onLoadSuccess(\n    data: LoadSuccessCallback<TModel, TTransport>\n  ): void {}\n\n  protected onLoadError(data: LoadErrorCallback<TModel, TTransport>): void {}\n\n  protected override notifyAdded(model: TModel): void {\n    model._onAdded(this, false)\n  }\n\n  protected override notifyRemoved(model: TModel): void {\n    model._onRemoved(this, false)\n  }\n\n  override destroy(): void {\n    super.destroy()\n\n    this._models.forEach((model) => {\n      model.destroy()\n    })\n    this._models = []\n  }\n}\n","import {\n  action,\n  computed,\n  IReactionDisposer,\n  makeObservable,\n  observable,\n  reaction\n} from 'mobx'\nimport { Model } from '../model/Model'\nimport {\n  AddConfig,\n  FactoryFn,\n  LiteCollectionConfig,\n  ModelInsertPosition,\n  RemoveConfig,\n  RequiredLiteCollectionConfig,\n  ResetConfig\n} from '../utils/types'\nimport { isPromise, wrapInArray } from '../utils/utils'\n\nexport class LiteCollection<\n  TModel extends Model<LiteCollection<any, any>>,\n  TFactory extends FactoryFn<TModel>\n> {\n  protected _models: TModel[] = []\n\n  protected modelByCid: Map<string, TModel> = new Map()\n\n  protected modelByIdentity: Map<string | number, TModel> = new Map()\n\n  protected config: RequiredLiteCollectionConfig\n\n  protected identityReactionByCid: Map<string, IReactionDisposer> = new Map()\n\n  constructor(protected factory: TFactory, config?: LiteCollectionConfig) {\n    this.config = {\n      add: {\n        insertPosition: 'end',\n        ...(config?.add ? config.add : undefined)\n      },\n      remove: {\n        destroy: false,\n        ...(config?.remove ? config.remove : undefined)\n      },\n      reset: {\n        destroy: false,\n        ...(config?.reset ? config.reset : undefined)\n      }\n    }\n\n    makeObservable<\n      this,\n      | 'addToCollection'\n      | 'removeFromCollection'\n      | 'modelByCid'\n      | '_models'\n      | 'modelByIdentity'\n    >(this, {\n      add: action,\n      _models: observable.shallow,\n      modelByCid: observable.shallow,\n      modelByIdentity: observable.shallow,\n      addToCollection: action,\n      removeFromCollection: action,\n      destroy: action,\n      syncing: computed,\n      deleting: computed,\n      saving: computed,\n      new: computed,\n      models: computed\n    })\n  }\n\n  getConfig(): RequiredLiteCollectionConfig {\n    return this.config\n  }\n\n  protected assertIsModel(model: unknown): asserts model is TModel {\n    /* eslint-disable-next-line no-prototype-builtins */\n    if (!Model.prototype.isPrototypeOf(model as any)) {\n      throw new Error(`model is not instance of Model class`)\n    }\n  }\n\n  push(model: TModel[]): TModel[]\n\n  push(model: TModel): TModel | undefined\n\n  push(model: TModel | TModel[]): TModel | TModel[] | undefined {\n    // https://stackoverflow.com/questions/65110771/how-to-have-functions-pass-arguments-with-the-same-overloads\n    return this.add(model as any)\n  }\n\n  add(model: TModel[]): TModel[]\n\n  add(model: TModel): TModel | undefined\n\n  add(model: TModel | TModel[]): TModel | TModel[] | undefined {\n    // @ts-expect-error - overload using overload\n    return this.addToCollection(model, { insertPosition: 'end' })\n  }\n\n  unshift(model: TModel[]): TModel[]\n\n  unshift(model: TModel): TModel | undefined\n\n  unshift(model: TModel | TModel[]): TModel | TModel[] | undefined {\n    // @ts-expect-error - overload using overload\n    return this.addToCollection(model, { insertPosition: 'start' })\n  }\n\n  addAtIndex(model: TModel[], index: number): TModel[]\n\n  addAtIndex(model: TModel, index: number): TModel | undefined\n\n  addAtIndex(\n    model: TModel | TModel[],\n    index: number\n  ): TModel | TModel[] | undefined {\n    // @ts-expect-error - overload using overload\n    return this.addToCollection(model, { insertPosition: index })\n  }\n\n  protected addToCollection(\n    model: TModel,\n    config: Omit<AddConfig, 'insertPosition'> & {\n      insertPosition?: number | ModelInsertPosition\n    }\n  ): TModel | undefined\n\n  protected addToCollection(\n    model: TModel[],\n    config: Omit<AddConfig, 'insertPosition'> & {\n      insertPosition?: number | ModelInsertPosition\n    }\n  ): TModel[]\n\n  protected addToCollection(\n    model: TModel | TModel[],\n    config: Omit<AddConfig, 'insertPosition'> & {\n      insertPosition?: number | ModelInsertPosition\n    }\n  ): TModel | TModel[] | undefined {\n    const models = wrapInArray(model)\n\n    const addConfig = {\n      ...this.config.add,\n      ...config\n    }\n    const newModels: TModel[] = []\n\n    for (const model of models) {\n      this.assertIsModel(model)\n      // model with the same id is already in the collection\n      if (!this.notPresent(model)) {\n        continue\n      }\n\n      newModels.push(model)\n\n      // const previousCollection = model.collection\n      // // model is already in some other collection\n      // if (previousCollection) {\n      //   previousCollection.removeFromCollection(model)\n      // }\n\n      this.startTracking(model)\n\n      // model._onAdded(this)\n      this.notifyAdded(model)\n\n      this.onAdded(model)\n    }\n\n    // add models to the collection\n    if (addConfig.insertPosition === 'end') {\n      this._models.push(...newModels)\n    } else if (addConfig.insertPosition === 'start') {\n      this._models.unshift(...newModels)\n    } else {\n      //number at index\n      if (\n        addConfig.insertPosition > this._models.length ||\n        addConfig.insertPosition < 0\n      ) {\n        throw new Error('insertion index out of bounds')\n      }\n      this._models.splice(addConfig.insertPosition, 0, ...newModels)\n    }\n\n    return Array.isArray(model) ? newModels : newModels[0]\n  }\n\n  protected notPresent(model: TModel): boolean {\n    const byCid = !this.modelByCid.get(model.cid)\n    let byIdentifier = false\n    const identifier = model.identity\n    // if there is an identifier value then we also need to check that\n    if (identifier) {\n      byIdentifier = !!this.modelByIdentity.get(identifier)\n    }\n\n    return byCid && !byIdentifier\n  }\n\n  protected startTracking(model: TModel): void {\n    this.modelByCid.set(model.cid, model)\n    const identifier = model.identity\n    if (identifier) {\n      this.modelByIdentity.set(identifier, model)\n    }\n\n    const idReaction = reaction(\n      () => model.identity,\n      (value) => {\n        this.modelByIdentity.set(value, model)\n      },\n      { name: `id-${model.cid}` }\n    )\n    this.identityReactionByCid.set(model.cid, idReaction)\n  }\n\n  protected stopTracking(model: TModel): void {\n    this.modelByCid.delete(model.cid)\n    this.modelByIdentity.delete(model.identity)\n\n    const reaction = this.identityReactionByCid.get(model.cid)\n    reaction ? reaction() : null\n  }\n\n  protected resolveModel(id: string): TModel | undefined {\n    const model = this.modelByIdentity.get(id)\n\n    return model || this.modelByCid.get(id)\n  }\n\n  protected resolveModels(needle: string | string[]): TModel[] {\n    const needles = wrapInArray(needle)\n    const models = []\n    for (const needle of needles) {\n      const model = this.resolveModel(needle)\n      if (model) {\n        models.push(model)\n      }\n    }\n\n    return models\n  }\n\n  create(data: Parameters<TFactory>[0]): ReturnType<TFactory> {\n    const result = this.factory(data)\n    if (isPromise(result)) {\n      result.then((model: TModel) => {\n        model.init()\n      })\n    } else {\n      result.init()\n    }\n\n    return result as ReturnType<TFactory>\n  }\n\n  getById(id: string): TModel | undefined\n\n  getById(id: string[]): TModel[] | undefined\n\n  getById(id: string | string[]): TModel | TModel[] | undefined {\n    if (Array.isArray(id)) {\n      return this.resolveModels(id)\n    }\n\n    return this.resolveModel(id)\n  }\n\n  get models(): ReadonlyArray<TModel> {\n    return this._models as ReadonlyArray<TModel>\n  }\n\n  get new(): TModel[] {\n    return this.models.filter((model) => {\n      return model.isNew\n    })\n  }\n\n  get deleted(): TModel[] {\n    return this.models.filter((model) => {\n      return model.isDeleted\n    })\n  }\n\n  get syncing(): TModel[] {\n    return this.deleting.concat(this.saving)\n  }\n\n  get deleting(): TModel[] {\n    return this._models.filter((m) => m.isDeleting)\n  }\n\n  get saving(): TModel[] {\n    return this._models.filter((m) => m.isSaving)\n  }\n\n  pop(config?: RemoveConfig): TModel | undefined {\n    if (this.models.length > 0) {\n      return this.removeFromCollection(\n        this.models[this.models.length - 1],\n        config\n      ) as TModel\n    }\n\n    return undefined\n  }\n\n  shift(config?: RemoveConfig): TModel | undefined {\n    if (this.models.length > 0) {\n      return this.removeFromCollection(this.models[0], config) as TModel\n    }\n\n    return undefined\n  }\n\n  removeAtIndex(index: number, config?: RemoveConfig): TModel | undefined {\n    if (index < 0 || index >= this._models.length) {\n      return undefined\n    }\n    const model = this._models[index]\n\n    return this.removeFromCollection(model, config) as TModel\n  }\n\n  remove(id: string, config?: RemoveConfig): TModel | undefined\n\n  remove(id: string[], config?: RemoveConfig): TModel[]\n\n  remove(\n    id: string | string[],\n    config?: RemoveConfig\n  ): TModel | TModel[] | undefined {\n    const resolved = this.resolveModels(id)\n    let final: TModel | TModel[] = resolved\n    if (!Array.isArray(id)) {\n      if (!resolved.length) {\n        return undefined\n      } else {\n        final = final[0]\n      }\n    }\n\n    // @ts-expect-error -generic type missmatch for some reason?\n    return this.removeFromCollection(final, config)\n  }\n\n  protected removeFromCollection(\n    model: TModel,\n    config?: RemoveConfig\n  ): TModel | undefined\n\n  protected removeFromCollection(\n    model: TModel[],\n    config?: RemoveConfig\n  ): TModel[]\n\n  protected removeFromCollection(\n    model: TModel | TModel[],\n    config?: RemoveConfig\n  ): TModel | TModel[] | undefined {\n    const modelCids = new Set(\n      wrapInArray(model).map((model) => {\n        return model.cid\n      })\n    )\n\n    const removed: TModel[] = []\n    const currentCount = this._models.length\n\n    const handleRemoval = (m: TModel): void => {\n      removed.push(m)\n      this.stopTracking(m)\n      this.notifyRemoved(m)\n      if (config?.destroy) {\n        m.destroy()\n      }\n      this.onRemoved(m)\n    }\n    // optimize for only one element\n    if (modelCids.size === 1) {\n      for (let i = 0; i < currentCount; i++) {\n        const model = this._models[i]\n        this.assertIsModel(model)\n        const inCollection = modelCids.has(model.cid) //model is in the collection\n        if (inCollection) {\n          this._models.splice(i, 1)\n          handleRemoval(model)\n          break\n        }\n      }\n    } else {\n      // go through whole array - todo - maybe optimize\n      const modelsToKeep = []\n      for (let i = 0; i < currentCount; i++) {\n        const model = this._models[i]\n        this.assertIsModel(model)\n        const inCollection = modelCids.has(model.cid)\n        if (inCollection) {\n          handleRemoval(model)\n        } else {\n          modelsToKeep.push(model)\n        }\n      }\n\n      this._models = modelsToKeep\n    }\n\n    return Array.isArray(model) ? removed : removed[0]\n  }\n\n  protected notifyRemoved(model: TModel): void {\n    model._onRemoved(this, true)\n  }\n\n  protected notifyAdded(model: TModel): void {\n    model._onAdded(this, true)\n  }\n\n  protected onRemoved(model: TModel): void {}\n\n  protected onAdded(model: TModel): void {}\n\n  serialize(): any {\n    return {\n      models: this.serializeModels(),\n      ...this.onSerialize()\n    }\n  }\n\n  protected serializeModels(): any[] {\n    return this._models.reduce<any[]>((arr, model) => {\n      const result = model.payload\n      if (result) {\n        arr.push(result)\n      }\n\n      return arr\n    }, [])\n  }\n\n  protected onSerialize(): any {}\n\n  protected async resetCollection<T>(\n    data?: T[],\n    config?: ResetConfig\n  ): Promise<TModel[][]> {\n    if (!data) {\n      const removed = this.removeFromCollection(this._models, config)\n\n      this.onReset([], removed)\n\n      return [[], removed]\n    }\n\n    const modelsToAdd: TModel[] = []\n    for (const modelData of data) {\n      const modifiedData = this.onModelCreateData(modelData)\n\n      if (!modifiedData) {\n        continue\n      }\n\n      const model = await this.factory(modifiedData)\n\n      modelsToAdd.push(model)\n    }\n\n    const removed = this.removeFromCollection(this._models, config)\n    const added = this.addToCollection(modelsToAdd, {\n      insertPosition: 'end'\n    })\n\n    this.onReset(added, removed)\n\n    return [added, removed]\n  }\n\n  reset<T>(modelData?: T[], config?: ResetConfig): Promise<TModel[][]> {\n    return this.resetCollection(modelData, config)\n  }\n\n  protected onReset(_added: TModel[], _removed: TModel[]): void {}\n\n  protected onModelCreateData(\n    data: Parameters<TFactory>[0]\n  ): Parameters<TFactory>[0] | void {\n    return data\n  }\n\n  destroy(): void {\n    this.onDestroy()\n\n    this.identityReactionByCid.forEach((dispose) => dispose())\n\n    this._models.forEach((model) => {\n      this.notifyRemoved(model)\n    })\n  }\n\n  protected onDestroy(): void {}\n}\n","import type { Model } from '../model/Model'\n\nexport interface Transport<TModel extends Model<any> = Model<any>, TDTO = any> {\n  load(config?: any): Promise<{ data: TDTO[] }>\n\n  save(model: TModel, config?: any): Promise<{ data?: any } | void>\n\n  delete(model: TModel, config?: any): Promise<{ data?: any } | void>\n}\n\nexport class StubTransport<TModel extends Model<any> = Model<any>, TDTO = any>\n  implements Transport<TModel, TDTO>\n{\n  load(): Promise<{ data: TDTO[] }> {\n    return Promise.resolve({ data: [] })\n  }\n\n  save(m: TModel): Promise<void> {\n    return Promise.resolve()\n  }\n\n  delete(): Promise<void> {\n    return Promise.resolve()\n  }\n}\n"],"names":["IdentityError","Error","constructor","message","super","this","name","Model","identityKey","collection","cid","errors","save","delete","_isDeleted","_isSaving","_isDeleting","ignoreChange","_isDestroyed","payloadActionDisposer","initialized","pendingSaveCall","lastSavedData","undefined","nanoid","makeObservable","init","action","observable","isDeleted","computed","isSaving","isDeleting","isDirty","isDestroyed","isSyncing","isNew","computePayload","struct","payload","setIdentity","identity","hasErrors","saveError","deleteError","_onAdded","_onRemoved","_onSaveStart","_onSaveSuccess","_onSaveError","_onDeleteError","_onDeleteStart","_onDeleteSuccess","destroy","startPayloadCompute","serialize","autorun","isLite","onAdded","onRemoved","config","transportConfig","token","state","onSaveStart","data","response","savedData","_this$pendingSaveCall","_this$pendingSaveCall3","setIdentityFromResponse","identityValue","extractIdentityValue","onSaveSuccess","error","dataToSave","onSaveError","newValue","modelIsNew","onDeleteStart","onDeleteSuccess","onDeleteError","modelIsDirty","equal","onDestroy","wrapInArray","item","Array","isArray","ASYNC_STATUS","PENDING","RESOLVED","REJECTED","IDLE","unwrapResult","result","Collection","factory","_models","modelByCid","Map","modelByIdentity","identityReactionByCid","add","insertPosition","remove","reset","shallow","addToCollection","removeFromCollection","syncing","deleting","saving","new","models","getConfig","assertIsModel","model","prototype","isPrototypeOf","push","unshift","addAtIndex","index","addConfig","newModels","notPresent","startTracking","notifyAdded","length","splice","byCid","get","byIdentifier","identifier","set","idReaction","reaction","value","stopTracking","resolveModel","id","resolveModels","needle","needles","create","Promise","isObject","then","catch","getById","filter","deleted","concat","m","pop","shift","removeAtIndex","resolved","final","modelCids","Set","map","removed","currentCount","handleRemoval","notifyRemoved","size","i","has","modelsToKeep","serializeModels","onSerialize","reduce","arr","async","onReset","modelsToAdd","modelData","modifiedData","onModelCreateData","added","resetCollection","_added","_removed","forEach","dispose","transport","loadError","loadStatus","_deleting","_saving","addImmediately","addOnError","destroyOnRemoval","removeImmediately","removeOnError","load","duplicateModelStrategy","compareFn","destroyOnReset","onLoadStart","onLoadSuccess","onLoadError","getTransport","saveConfig","runInAction","callTransportSave","tokenData","callTransportDelete","callTransportLoad","values","deleteConfig","modelCanBeDeleted","e","assertModelIsExists","_data","loadConfig","modelsToRemove","oldModel","compareResult","StubTransport","resolve"],"mappings":"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"}
import { Model } from '../model/Model';
import { Transport } from '../transport/transport';
import { CollectionConfig, DeleteConfig, DeleteErrorCallback, DeleteResult, DeleteStartCallback, DeleteSuccessCallback, FactoryFn, LoadConfig, LoadErrorCallback, LoadResult, LoadStartCallback, LoadSuccessCallback, RequiredCollectionConfig, SaveConfig, SaveErrorCallback, SaveResult, SaveStartCallback, SaveSuccessCallback, TransportDeleteConfig, TransportLoadConfig, TransportSaveConfig } from '../utils/types';
import { ASYNC_STATUS } from '../utils/utils';
import { LiteCollection } from './LiteCollection';
export declare class Collection<TModel extends Model<Collection<any, any, any>>, TFactory extends FactoryFn<TModel>, TTransport extends Transport<TModel>> extends LiteCollection<TModel, TFactory> {
    protected transport: TTransport;
    loadError: undefined;
    loadStatus: keyof typeof ASYNC_STATUS;
    _deleting: Map<string, TModel>;
    protected _saving: Map<string, {
        token: Record<string, never>;
        model: TModel;
    }>;
    protected config: RequiredCollectionConfig;
    constructor(factory: TFactory, transport: TTransport, config?: CollectionConfig);
    getConfig(): RequiredCollectionConfig;
    getTransport(): TTransport;
    save(model: TModel, config?: SaveConfig, transportConfig?: TransportSaveConfig<TTransport>): Promise<SaveResult<TModel, TTransport>>;
    protected callTransportSave(model: TModel, config?: TransportSaveConfig<TTransport>): Promise<import("../utils/types").UnwrapPromise<ReturnType<TTransport["save"]>>>;
    protected callTransportDelete(model: TModel, config?: TransportDeleteConfig<TTransport>): Promise<import("../utils/types").UnwrapPromise<ReturnType<TTransport["delete"]>>>;
    protected callTransportLoad(config?: TransportLoadConfig<TTransport>): Promise<import("../utils/types").UnwrapPromise<ReturnType<TTransport["load"]>>>;
    protected onSaveStart(data: SaveStartCallback<TModel, TTransport>): void;
    protected onSaveSuccess(data: SaveSuccessCallback<TModel, TTransport>): void;
    protected onSaveError(data: SaveErrorCallback<TModel, TTransport>): void;
    get deleting(): TModel[];
    get saving(): TModel[];
    delete(id: string, config?: DeleteConfig, transportConfig?: TransportDeleteConfig<TTransport>): Promise<DeleteResult<TModel, TTransport>>;
    protected modelCanBeDeleted(model?: TModel): asserts model is TModel;
    protected assertModelIsExists(model?: TModel): asserts model;
    protected onDeleteStart(data: DeleteStartCallback<TModel, TTransport>): void;
    protected onDeleteSuccess(data: DeleteSuccessCallback<TModel, TTransport>): void;
    protected onDeleteError(_data: DeleteErrorCallback<TModel, TTransport>): void;
    load(config?: LoadConfig, transportConfig?: TransportLoadConfig<TTransport>): Promise<LoadResult<TModel, TTransport>>;
    protected onLoadStart(data: LoadStartCallback<TModel, TTransport>): void;
    protected onLoadSuccess(data: LoadSuccessCallback<TModel, TTransport>): void;
    protected onLoadError(data: LoadErrorCallback<TModel, TTransport>): void;
    protected notifyAdded(model: TModel): void;
    protected notifyRemoved(model: TModel): void;
    destroy(): void;
}
